# 1장 단위테스트 개요
## 단위테스트를 해야하는 이유
### 단위테스트는 소프트웨어가 지속적으로 확장해 나갈 시 장기적으로 개발속도를 유지하기 위해서 필요하다.
#### 근거
##### 회귀에 대한 보험
(회귀는 특정 사건 후에 기능이 의도한대로 작동하지 않는 경우 = 버그)

소프트웨어 엔트로피가 높아질 수록 소프트웨어는 지속적인 성장이 어려워진다.
소프트웨어 엔트로피를 관리하기 위해서는 반드시 지속적으로 정리와 리팩토링을 수행해야한다.

소프트웨어 엔트로피란?
제품의 설계 및 소프트웨어의 확립된 설계 원칙 및 일관성을 유지하지 않을경우 소프트웨어가 썩는(Software rot)현상이 나타난다는 것.
(출처 : [위키백과](https://en.m.wikipedia.org/wiki/Software_entropy) )

다음은 소프트웨어 엔트로피에 대한 조언.
* 깨진 창문을 내버려두지 말라.
* 나쁜 설계, 잘못된 결정, 혹은 형편없는 코드를 고치지 않은 채로 내버려 두지 마라. 발견하자마자 고쳐라
* 깨진 창문이 꽤 있는 프로젝트를 한다면, ‘나머지 코드가 전부 쓰레기니까 나도 그렇게 하지 뭐’라는 사고로 빠져들기 너무도 쉽다.
* 코드가 … 깨끗하고, 잘 설계되었으며 우아한 프로젝트와 팀에 여러분이 속해 있다면, 아마도 … 특별한 주의를 기울여서 엉망으로 만들지 않도록 도력할 확률이 높다.
* 적어도 엉망진창으로 만드는 첫번째 사람이 자신이 되는 것만은 피하려 한다.
(출처 : 실용주의 프로그래머)
즉 [코드의 냄새](https://en.m.wikipedia.org/wiki/Code_smell)가 보일때마다 리팩토링하고 수정하라는 것..
이러한 행위를 하기위해서는 …

단위테스트가 새로운 기능의 요구사항에 맞도록 리팩토링 하거나 기존 기능을 변경시에 기존기능이 잘 작동하는지 확인하는데 도움이 된다.
즉 기능 변경에 대한 회귀 방지로서 작동이 가능하다는 의미.

즉,
1. 시간이 지남에 따라 코드 성장
2. 소프트웨어 엔트로피 증가 방지를 위해 리팩토링 혹은 코드정리
3. 리팩토링 혹은 코드정리시 발생하는 코드 변경에 대한 정상 작동을 체크하기 위해 단위테스트가 효율적.
4. 결론적으로 단위테스트가 소프트웨어의 지속적인 성장을 위해 필요함.

### 단위테스트의 단점
단위테스트는 초기에 상당한 노력이 들어갈 수 있다.
하지만 후반의 성장이 초반의 노력의 비용을 상당부분 상쇄가능하다.

### 단위테스트가 소프트웨어의 더 나은 설계로 이어질 수 있음
하지만 주된 목표는 아니다.
단위테스트를 할 수 있도록 코드를 변경하는 과정에서 더 나은 설계로 코드가 바뀌는것은 단위테스트의 사이드 이팩트.

단위 테스트를 작성할 수 없다는 것은 설계가 좋지 않다는 괜찮은 부정지표지만
단위 테스트를 작성할 수 있다고 설계가 좋다 라고 하는것은 좋지 않은 긍정 지표임.
즉 단위테스트를 작성할 수 없으면 설계가 안좋은 코드가 맞지만 작성할 수 있다고해서 무조건 설계가 좋은 코드라는것은 아님.

### 무엇이 좋은 테스트인가?
테스트 코드를 작성할 때는 프로젝트에 명확히 도움이 되는지 명확히 파악한후 테스트를 작성해야한다.
테스트를 작성할 때는 테스트의 가치와 유지비용을 모두 고려해야한다.
고품질의 테스트만이 테스트 스위트에 남아야하며 무의미하거나 의미없는 테스트는 오히려 유지비용을 증가시킬 뿐이다.
왜냐하면 테스트 또한 코드이기 때문에 테스트에서도 버그가 발생이 가능하며 유지보수 비용이 발생하기 때문이다.
자세한 내용은 4장에서…

## 코드 커버리지
### 커버리지란 무엇일까?
커버리지란 테스트 코드가 소스코드를 얼마나 실행하는지를 백분율로 나타낸것임.
#### 코드 커버리지
코드 커버리지는 테스트 코드가 제품 코드를 얼마나 실행하고 있는가를 백분율로 나타낸것이다.

즉,
제품 코드 5줄, 분기 등으로 인해 테스트 코드가 제품 코드 4줄만 실행한다면
테스트 커버리지는 4/5 = 0.8 즉 80%의 커버리지라고 할 수 있음.
테스트 코드가 얼마나 많은 제품코드를 실행하는지에 대한 지표라고 할 수 있음.

다음과 같은 예시 때문에 코드 커버리지가 높다고 항상 좋은것은 아님.
```
public static bool IsStringLong(string input) 
{
    if (input.Length > 5) 
        return true;
    return false;
}

public void Test() {
    bool result = IsStringLong(“abc”);
    Assert.Equal(false, result);
}
```

위와 같은 테스트 코드가 있을때 코드 커버리지는 input.Length 가 5이하인 경우만 테스트 하기 때문에 코드 커버리지는 한줄이 실행되지 않아 4/5 = 0.8로 80%임.
하지만 코드를 다음과 같이 수정한다면 코드 커버리지는 100%로 바뀜
```
public static bool IsStringLong(string input)
{
    return input.Length > 5;
}
```
숫자는 올랐지만 유지보수성과 테스트의 가치가 올라간 것은 아님.

#### 분기 커버리지
분기 커버리지는 코드 커버리지와 다르게 if문과 switch 문 과같은 제어 구조에 중점을 두고 검사함.

전체 분기 수 대비 코드 커버리지가 통과하는 분기수를 백분율로 나타낸다.

코드 커버리지에서 사용된 코드의 예시를 본다면,
```
public static bool IsStringLong(string input)
{
    return input.Length > 5;
}

public void Test() {
    bool result = IsStringLong(“abc”);
    Assert.Equal(false, result);
}
```
위 코드의 코드 커버리지는 100% 였지만 분기의 경우
input.Length 가 5이하에서만 테스트 된다. 따라서
5 이상의 분기에 대해서 테스트하는 코드가 없으므로
분기 커버리지는 1/2 = 0.5 = 50%

분기 커버리지는 분기를 더 짧게 축소하더라도 분기의 개수만을 다루기 때문에 분기 커버리지 숫자에는 영향을 주지 않는다.

### 코드 커버리지의 문제점
테스트 코드의 품질을 측정하는데 어떤 커버리지도 의존할 수 없다.

#### 근거
##### 커버리지를 높히기 위해서 단지 코드만 실행하고 어떠한 검증을 하지 않더라도 커버리지는 증가함.
다음 과 같은 극단적인 예시로 볼 수 있음.

```
public static bool IsStringLong(string input)
{
    return input.Length > 5;
}

public void Test() {
    bool result = IsStringLong(“abc”); // false
    bool result = IsStringLong(“abcdef”); // true
}
```
위 코드는 분기 커버리지와 코드 커버리지 모두 100%를 달성함.
하지만 적절한 검증구문이 없으므로 제대로된 단위테스트를 한다고 보기 어려움.

##### 외부라이브러리의 코드 경로를 고려할 수 없음.
다음 코드로 예시를 볼 수 있음
```
public static int Parse(string input)
{
    return int.Parse(input)
}
public void Test() {
    int result = Parse(“5”);
    Assert.Equal(5, result);
}
```
int.Parse는 c#의 내장 라이브러리로
위 코드 또한 분기가 없기에 분기커버리지는 측정되지 않고 코드커버리지 또한 100%로 측정되지만, 정작 int.Parse 함수의 경우 파싱할 수 없는 문자열이나 null이 들어갈 경우 예외가 발생하게됨.

따라서 커버리지 지표를 유닛테스트의 품질을 측정하는데 사용하는것은 무리가 있음.

### 결론, 그럼 커버리지는 어디에 쓰는 건가요?
예를 들면 다음과 같은 상황.

* 시간이 지남에 따라 커버리지가 점점 낮아지고 있다, 즉 테스트 코드가 부족해지고 있다 라는 판단에 단위테스트가 부족한곳이 있는지 점검 할 수 있다.
* 새로 작성한 코드의 분기 커버리지가 너무 낮다 = 테스트하지 않은 케이스가 있는지 검사 해볼 수 있다

와 같은 형태로 커버리지 지표 자체가 프로젝트의 현상황에 어떤 의미를 갖는지 능동적인 판단이 필요해보인다.

이 지표 또한 좋은 부정지표이며, 나쁜 긍정 지표로 사용해라.

### 성공적인 단위테스트
단위테스트의 품질은 각 개별의 테스트를 따로따로 수동으로 평가해야한다.
단위테스트의 품질을 자동으로 확인 할 수 있는 방법은 없다.

#### 성공적인 단위테스트를 위한 요건

##### 개발주기에 통합해서 항상 수행할것.
테스트 코드를 끊임없이 테스트한다.
CI나 코드리뷰 과정등 단위테스트를 개발과정에 통합시키자.

##### 코드베이스에서 중요한 부분을 대상으로 수행할 것.
꼭 테스트 하지 않아도되고, 테스트해도 효과가 적은 코드에 대해서 단위테스트를 작성하는 것은 관리해야할 코드만 늘리는 꼴이며 효과적이지도 않다.
코드에서 중요한 부분이라고 한다면 비지니스 로직이 그러함.
비지니스로직은 프로젝트에서 가장 핵심이 되고 가치 있는 곳임, 또한 요구사항 변경에 따라서 자주 리팩토링 되는곳 자주 변경되는 곳 또한 비지니스 로직이다.

##### 최소의 유지비용으로 최대의 가치를 끌어낼것
제품코드는 테스트코드와 서로 많은 영향을 받음.
제품코드에 노력을 기울이지 않는다면 가치있는 테스트 코드를 만들 수 없다.
*즉, 좋은 설계가 가치있는 테스트를 만든다.*

### 개인적인 정리
* 단위테스트는 중요한 코드 베이스에 대해서 투자해야한다.
* 단위테스트를 위해서는 좋은 코드를 설계하는 것이 중요하다.
* 단위테스트는 개발주기에 포함하자. (CI를 통해서 코드를 커밋하면 단위테스트를 실행. 코드 리뷰에서는 단위테스트에 대한 평가를 같이 진행함 등..) 개인적인 경험으로 보았을때 단위테스트가 개발주기에 통합되어 있지 않다면 재대로 진행되지 않을 확율이 높다.
* 커버리지 지표는 그냥 상황에 대한 판단을 위한 참고만…
* 모든 일이 그러하지만 단위테스트는 특히 최소한의 유지비로 최대의 가치를 끌어내기 위한 노력이 더욱 많이 필요함