# 데이터베이스 테스트

## 데이터베이스 테스트를 위한 전제 조건
데이터베이스 테스트를 위해서는 다음 3가지 전제조건이 존재한다.
- 형상 관리 시스템에 데이터베이스 유지
- 모든 개발자를 위한 별도의 데이터베이스 인스턴스 사용
- 데이터베이스 배포에 마이그레이션 기반 방식 적용

### 형상 관리 시스템에 데이터베이스 유지
    - 데이터베이스 스키마를 일반 코드로 취급한다.
            - 일반 코드처럼 스키마는 형상관리 시스템에 저장한다.
        - 모델 데이터베이스를 운영하여 개발시 모델 데이터베이스에 스키마를 업데이트 하는 형태의 개발을 사용할 수 있지만, 형상관리 시스템에 비해 단점이 존재한다.
            - 단점1. 변경 내역 부재 : 스키마를 업데이트에 대한 기록이 없어 스키마를 특정시점으로 돌리는 것이 불가능하다.
            - 단점2. 복수의 원천 정보 : 모델 데이터베이스는 개발 상태에 대한 원천정보를 둘러싸고 경합함. (데이터의 원천 정보가 소스 저장소, 모델 데이터베이스로 두가지가 되는 경우를 들 수 있다.)
        - 여기서 모델 데이터베이스는 개발 시 사용되는 데이터베이스 인스턴스를 말하는듯함.
    - 참조 데이터도 스키마로 취급한다.
        - 데이터베이스의 주요 구성요소는 테이블 뷰, 인덱스, 저장프로시저 등이 있다.
        - 데이터베이스 스키마에 속하지만 스키마로 거의 여겨지지 않는 부분이 참조데이터이다.
            - 참조 데이터는 데이터베이스 설정시 기본적으로 함게 설정되어야 하는 값으로 데이터베이스를 생성하는 스크립트와 함께 SQL INSERT문과 같은 형태로 설정되어야 한다.
        - 참조 데이터 또한 스키마로 취급하여 형상관리 시스템에 추가되어야한다.
### 모든 개발자를 위한 별도의 데이터베이스 인스턴스 사용
    - 실제 데이터베이스를 통해 테스트하는 것은 어렵기 때문에 개발자의 장비에서 실행가능한 데이터베이스를 사용해야함.
    - 공유 데이터베이스를 사용해서 테스트 할경우 서로의 테스트가 간섭될 수 있고, 하위호환성이 없는 변경으로 다른 개발자의 작업을 방해 할 수 있기 때문이다.
### 데이터베이스 배포에 마이그레이션 기반 방식 적용
    - 데이터베이스 배포에는 상태기반과 마이그레이션 기반이라는 두가지 방식이 있다. 마이그레이션 방식이 초기구현과 유지보수가 어렵지만 장기적으로 상태기반보다 효과적이다.
    - 상태 기반 방식
        - 배포 중 비교스크립트가 개발중 사용했던 모델 데이터베이스에서 운영 데이터베이스를 비교해서 마이그레이션을 위한 스크립트를 생성하는 방식이다.
        - 자동화 도구를 사용하게 된다.
    - 마이그레이션 기반 방식
        - 데이터를 마이그래이션 하기위한 코드를 일일히 작성하는 방식이다.
        - 마이그레이션을 위한 코드를 형상관리에 저장하게 된다.
    
    - 상태 기반 방식보다 마이그레이션 기반 방식을 선호하라.
        - 데이터 모션 문제를 하는데 도움이 되기 때문이다.
            - 데이터 모션 : 새로운 데이터베이스 스키마를 준수하도록 기존 데이터를 변경하는 과정.
        - 상태 기반 방식에서 스크립트를 생성할때 데이터 모션을 적절하게 해결할 수 있는 방법이 없다.

## 데이터베이스 트랜잭션 관리
### 제품 코드에서 데이터베이스 트랜잭션 관리하기.
- 트렌젝션은 데이터 모순을 피하기 위해 잘 관리되어야 한다.
- 데이터베이스 트랜젝션은 작업단위 (unit of work) 패턴을 통해 하나의 작업에서 하나의 트렌젝션이 발생되도록 하라.
    - 그렇지 않을 경우 데이터 모순이 발생할 수 있음.. 데이터를 저장하던도중 exception이 발생해서 저장해야하는 다른 작업이 완료되지 않는다던지..
- 대부분의 ORM 에서는 unit of pattern이 구현되어있다.

### 통합 테스트에서 데이터베이스 트랜잭션 관리하기
- 준비구절에서 사용한 트랜잭션이나 작업단위를 검증에서 사용할 경우 재대로된 검증이 안될 수 있음.
    - 대부분의 작업단위나 컨텍스트가 값을 캐싱할 수 있기 때문에 준비 단위에서 사용한 값을 그대로 캐싱해서 읽어와 검증에 사용할경우 재대로된 검증이 안되기 때문임.

## 테스트 데이터 생명 주기
공유 데이터를 사용할 경우 통합테스트를 서로 분리할 수 없는 문제가 생긴다.
이 문제를 해결하기 위해서는
- 통합테스트를 순차적으로 실행한다.
- 테스트 실행 간에 남은 데이터를 제거한다.

### 통합테스트를 순차적으로 실행한다.
- 통합 병렬로 테스트할 경우 병렬로 테스트하기위해 너무 많은 노력이 발생한다.
- 따라서, 통합테스트는 순차적으로 실행하는 것이 더욱 실용적이다.

### 테스트 실행 간에 남은 데이터를 제거한다.
테스트 실행 간에 남은 데이터를 정리하는 방법은 네가지가 있다
- 각 테스트 전에 데이터베이스 백업 복원
    - 컨테이너를 새롭게 생성하는데 몇초가 소모되기 떄문에 많이 느려진다.
- 테스트 종료 시점에 데이터 정리하기
    - 빠르지만 종료시점에 데이터를 정리하므로 테스트 중간에 문제가 발생하면 데이터가 정리가 안될 수 있는 문제가 있다.
- 데이터베이스 트랜잭션에 각 테스트를 래핑하고 커밋하지 않기
    - 데이터가 커밋되지 않으므로 자동으로 롤백되지만 운영환경과 다른 설정이 구성되는것이 문제다.
- 테스트 시작 시점에 데이터 정리하기
    - 가장 적절한 방식.
    - 빠르며 데이터 정리가 누락될일이 없다.
따라서 테스트 시작전에 데이터베이스룰 초기화 하는 작업을 수행하는 기초클래스를 작업한다. (기초 클래스는 데이터베이스 테스트를 수행하는 관련 테스트 클래스가 상속받는 부모클래스를 뜻함)

### 인메모리 데이터베이스 피하기
- 인메모리 데이터베이스는 장점도 있지만 일반 데이터베이스는 기능적으로 일관성이 없기 때문에 운영환경과 테스트 환경이 달라지는 문제가 발생할 수 있다.

## 테스트 구절에서 코드 재사용
- 통합테스트는 가능한 짧게 하되 서로 결합하거나 가독성에 영향을 주지 않도록 한다.
- 진행 상황을 이해하기 위헤 테스트 클래스의 다른부분을 검사해서는 안된다.
    - 테스트가 무엇을 위한 테스트인지 컨텍스트가 흐러지기 때문이다.
- 준비구절에서는 오브젝트 마더를 통해 코드를 재사용할 수 있다. (팩토리 메서드를 사용하면됨.)
    - 빌더페턴을 사용할 수 있지만 너무 많은 상용구를 만들어 가독성이 떨어지기에 오브젝트 마더가 선호된다.
    - 팩토리 메서드는 기본적으로는 테스트와 동일한 위치를 유지하되 다른 테스트에서도 사용할 일이 있다면 헬퍼클래스로 이동한다.
- 실행 구절에서는 데코레이터 메서드를 작성하여 실행구절을 재사용할 수 있다.
    - 실행을 위한 공통된 객체등을 생성할 경우.
- 검증 구절에서는 플루언트 인터페이스를 사용하여 코드를 재사용할 수 있다.
    - 부가 효과로 읽기 쉬워진다.

## 개인적인 정리
- 클라이언트에서는 데이터베이스를 실제로 사용할 일은 잘없지만 트랜젝션관리와 같이 데이터의 무결성에 관련된 부분은 도움이 될것같다.
- 그 외에는 사실상 데이터베이스에대한 일반적인 사항이었던것같다.

