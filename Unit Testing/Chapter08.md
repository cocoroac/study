# 통합 테스트를 하는 이유

## 통합테스트란?
- 통합테스트의 역할
    - 단위테스트의 세가지 조건중 어느 한가지 이상을 만족하지 못하는 경우 통합테스트이다.
        - 단일 동작 단위를 검증한다.
        - 빠르게 수행된다.
        - 다른 테스트와 격리되어 수행된다.
    - 결과적으로 통합테스트의 대부분은 시스템이 프로세스 외부 의존성과 어떻게 통합하는가를 테스트한다.
        - 단위테스트는 프로세스 외부 의존성에 대한 테스트를 하지 않으므로.
    - 결론적으로 통합테스트는 테스트 사분면에서 컨트롤러에 해당하는 코드를 테스트하게 된다.
- 통합 테스트와 단위테스트 간의 균형유지
    - 통합 테스트는 프로세스 외부 의존성등 단위테스트보다 많은 코드를 거치므로 회귀방지가 단위테스트보다 우수하다.
    - 통합 테스트는 제품코드와 결합도가 더욱 낮기 때문에 리펙터링 내성도 우수하다.
    - 일반적으로 단위 테스트로 가능한 많은 비지니스 시나리오의 예외사항을 확인하고 통합 테스트는 [주요 흐름](https://en.wikipedia.org/wiki/Happy_path)(에러가 나지 않는 의도한 흐름)과 단위테스트가 다루지 못하는 기타 예외 사항([edge case](https://en.wikipedia.org/wiki/Edge_case)을 테스트한다. 
    - 저자의 경험상으로 대부분 단위 테스트로 테스트하고 비지니스 시나리오별로 한두개의 통합 테스트만 있다면 대부분 전체의 시스템 정확도를 보장할 수 있다는 듯하다.
- [빠른 실패](https://en.wikipedia.org/wiki/Fail-fast)
    - 어플리케이션이 전제조건이 맞지않으면 항상 실패하도록 작성함.
    - 이러한 실패는 통합테스트시 옳은 패스만을 테스트 할 수 있도록하고 혹여 잘못된 조건으로 코드를 실행하고자 할 때도 잘못된 동작을 하는것을 막아줌.

## 어떤 프로세스 외부 의존성을 직접 테스트 해야하는가?
- 아래는 5장 내용의 반복.
    - 의존성은 두가지 종류가 있다.
        - 관리 의존성
            - 상호작용이 외부로 드러나지 않는다.
            - 외부에서 사이드 이팩트를 볼 수 없다.
        - 비관리 의존성
            - 상호작용이 외부로 드러난다.
            - 외부에서 볼 수 있는 사이드 이팩트가 있다.
    - 통합테스트에서 관리 의존성은 구현의 세부사항이기 때문에 직접 테스트한다.
        - 관리 의존성의 경우 목으로 테스트할경우 잦은 변경이 일어날 수 있어 리팩터링 내성이 떨어지게되기 때문이다.
    - 비관리 의존성은 목으로 관리한다.
        - 비관리 의존성은 하위호환성을 유지해야하기 때문에 목으로 테스트 가능하다.
- 관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성
    - 다른 어플리케이션에서 접근가능한 데이터베이스의 경우 관리 의존성이면서 비관리 의존성이 될 수 있다.
    - 가능하면 이러한 구현은 시스템이 서로 결합되기 때문에 좋은 구현은 아니지만 이렇게 구현되었을 경우 비관리 테이블과 관리 테이블로 나눈뒤 비관리 테이블을 목으로 테스트 하는 형태로 대체 가능하다.
- 통합테스트에서 실제 데이터베이스를 사용 할 수 없는 경우
    - 데이터베이스를 테스트환경으로 테스트할 수 없는경우를 말한다.
    - 데이터베이스와 같은 관리 의존성을 목으로 데체하는 것은 리팩터링 내성을 떨어트리는 일일뿐이고 이렇게 테스트하더라도 회귀방지에는 의미가 없다.
    - 따라서 이럴경우 테스트를 하지 않으며 단위테스트에 집중하는 것으로 충분하다.

## 의존성 추상화를 위한 인터페이스 사용
- 인터페이스에 대한 오해
    - 단일 구현을 위한 인터페이스는 추상화가 아니다.
    - 단일 구현을 위한 인터페이스는 구체 클래스보다 결합도가 낮지 않다.

- YAGNI(You aren't gonna need it)
    - 필요할 때 까지 구현하지 않는다.
    - 과도한 명세를 하지 않는다.
    - 즉 인터페이스도 필요할때까지 사용하지 않는다.
    - 프로그래머들이 예상되는 추가 기능에 대비하여 미리 인터페이스로 코드를 추상화 하는 경우가 있는데 이럴경우 과잉명세가 될 수 있다.
    - 코드베이스는 작을 수록 좋고 쓸데없는 기능을 구현하는 것은 시간낭비로 이어질 수 있기 때문에 YAGNI를 지키자.

- 그럼 인터페이스는 언제쓰나?
    - 인터페이스에 구현이 하나만 있더라도 목을 사용하기 위해서 사용한다.
    - 프로세스 외부 의존성 중에서도 비관리 의존성만 목으로 대체해야하므로 비관리 의존성만 인터페이스로 작성한다.

## 통합테스트 모범사례
### 통합테스트를 최대한 활용하는데 도움이 되는 지침
- 도메인 모델 경계 명시하기
    - 도메인 모듈의 경계를 명시적으로 할경우 코드를 이해하기가 쉬워지며 컨트롤러와 도메인의 경계가 명확해지므로 통합테스트와 단위테스트의 차이점을 명확히 구분할 수 있다.
    - 구분 방법은 네임스페이스, 어셈블리 (c#에서 라이브러리 형태를 의미함.), 패키지, 라이브러리등 어떤것이든 뚜련한것이 좋음.
- 에플리케이션 내 계층 줄이기
    - 간접계층이 많을 경우 컨트롤러와 도메인 모듈사이의 경계가 명확하지 않아진다.
    - 테스트를 작성할때 각 계층을 테스트하게 되므로 통합테스트의 가치가 떨어지게된다.
        - 통합테스트는 가능한 많은 코드베이스를 테스트하여 회귀방지에 큰 가치가 있으므로...
    - 갼접계층을 가능한 적계 사용하는 것이 통합테스트에 도움이 된다.
- 순환 의존성 제거하기
    - 순환 의존성은 둘이상의 클래스가 서로를 참조하여 의존하는 것을 말한다.
    - 순환 의존성은 코드를 이해할때 어려움을 준다.
        - 하나의 클래스를 이해하기위해 주변 클래스 그래프를 모두 이해해야하기 때문.
    - 따라서 테스트를 작성하기가 어려워지며 순환의존성을 목으로 처리해야하는 경우가 많아진다.
        - 도메인 모델에는 목을 사용하지 말라는 지침에 따라 도메인 모델에서 순환의존성은 피해야한다.
    - 순환의존성이 보이면 가능하면 제거하도록 해야한다.

### 테스트에서 다중 실행 구절 사용
- 통합테스트에서도 준비 실행 검증 구절의 형태를 유지하는 것이좋다. (실행구절을 호출한뒤에 다시 다른 실행구절을 실행하고 검증하지 말라는 의미)
    - 왜냐하면 테스트가 초점을 잃고 매우 커질수 있기 때문.
- 통합테스트에서 이러한 예외가 허용되는것은 유일하게 외부 의존성 관리가 어려울 때 뿐이다.
    - 외부 의존성에 대한 관리나 유지보수가 어려울 경우 하나의 테스트에서 여러가지 실행을 검증하는 것이 효율적일 수 도 있음.

## 로깅을 테스트 하는 방법
- 로깅은 지원 로깅과 진단로깅이 있다.
    - 지원 로깅
        - 지원 담당자나 시스템 관리자가 추적하기 위한 메세지를 생성하는 로깅.
    - 진단 로깅
        - 개발자가 어플리케이션의 내부 상황을 파악하기 위한 로깅
- 지원 로깅을 테스트한다.
    - 지원로깅은 비지니스 요구사항이다. 따라서 기능에 대한 테스트가 필요할 수 있다.
    - 로거의 구조를 비지니스에 맞는 이름으로 명명해 구조화하여 이해하기 쉽고 테스트 가능한 구조로 만든다.
    - 도메인 모델에 로거를 삽입하기 보단 도메인 모델의 특정지점에 이벤트를 만들고 이벤트 소싱의 형태로 이벤트를 받아 로거를 구현하게 하므로 도메인 모델에서 로거를 분리할 수 있다.
- 진단로깅은 테스트할 필요가 없다.
    - 요구사항이 아니기 때문이다.
    - 해당 코드는 유지할 이유가 없으며 디버깅등의 목적을 달성한뒤에는 제거되어야한다.

## 개인적인 정리
 - 기타 예외 사항이라고 쓰고 edge case라고 병기했는데 edge case만을 말하고 싶었던건지.. 모르겠다.
 - 그동안 별 의미없는 인터페이스를 많이 사용했다는 생각이 들었다.
    - 쓸데없는 추상화를 하지말자.
    - 평소에도 코드를 인터페이스로 작성하면서 이러면 그냥 구현의 세부사항이 아닌가? 전혀 추상화 되지 않은 인터페이스가 아닌가? 그렇다면 인터페이스로 작성할 이유가 없지 않을까? 에 대해서 다시 생각할 수 있었다.
 - 로깅에 대한 내용은 갑자기 튀어나왔는데 결국 관리 의존성과 비관리 의존성으로 로깅의 기능을 나누고 비관리 의존성의 로깅 부분을 목으로 처리한 예제를 보여준 것으로 보인다.