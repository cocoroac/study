# 3장 단위테스트 구조
### 단위테스트를 구성하는 방법

## AAA 패턴

- AAA 패턴은 arrange, act, assert(준비, 동작, 검증)로 3A 패턴으로도 불림
- 모든 테스트를 준비, 동작, 검증으로 나누기 때문에 일관성 유지에 도움을 준다.
- 구조
    - 준비 구잘 : SUT와 해당 의존성을 원하는 상태로 만든다.
    - 실행 구절 : SUT메서드를 호출 및 의존성 전달, 출력값이 있을경우 출력값을 저장한다.
    - 검증 구절 : 결과값, SUT 및 협력자의 최종상태 등을 검증한다.

* Given-When-Then 패턴
 - AAA패턴과 동일하지만 프로그래머가 아닌사람도 읽기 쉽도록 작성한 테스트.

## 테스트 작성 지침
- 여러개의 준비 실행 검증 구절 피하기
    - 준비 -> 실행 -> 검증 -> 실행 -> 검증 과같이 여러번의 실행 검증구절이 등장하는 경우를 말함.
    - 이와같은 형태는 너무 많은 것을 테스트하고 검증한다는 의미이기도 하다.
    - 실행이 한번일때 테스트의 범주(동작당 테스트)를 보장하고, 간단하고, 빠르고 이해가 쉬움.
    - 이와같은 테스트는 여러개의 동작이 실행되는 통합테스트에서 사용할 수 있음.

- 테스트 내 if 문 피하기
    - if문이 있는 단위테스트는 안티패턴임.
    - 분기가 필요할경우 테스트를 나누는것이 바람직하다.
    - *테스트에 분기가 있으면 이해만 어려워지며 얻는 이득은 업음.*

- AAA에서 각 테스트 구절의 크기
    - 준비 구절
        - 준비구절은 커질 수 있다.
        - 너무 클 경우 준비구절을 준비하는 팩토리 클래스나 비공개 메서드로 도출하는 것이 좋음.
        - 준비구절 재사용에 도움을 주는 패턴으로 오브젝트마더, 테스트 데이터 빌더 패턴이 있다.

    - 실행 구절
        - 실행 구절은 한줄 이상일 경우 SUT의 코드 점검이 필요함.
        - 만약 실행구절이 여러줄이 될경우 *불변 위반(invariant violation)*이 일어나지 않도록 캡슐화를 하는것이 중요
            - invariant violation = 데이터 정합성 위반으로 이해하면 될듯.
        - 유틸리티나 인프라코드는 두줄이상의 실행이 필요할 수 있으므로 반드시 한줄 이어야 한다는 의미는 아님.

    - 검증 구절
        - 동작에 대한 모든 결과를 검증하도록 작성한다.

- 테스트 작성시 SUT 변수명은 SUT로
    - SUT는 동작에대한 진입점을 제공하는 역할을한다.
    - 여러 클래스에 걸쳐서 동작이 수행되더라도 진입점은 오직 하나가 된다.
    - 따라서 SUT와 의존성을 명확히 구분할 수 있도록 SUT의 변수명은 SUT로 해줄경우 테스트를 읽을때 SUT를 빠르게 찾을 수 있다.

- 준비, 실행, 검증 주석
    - AAA의 각 구절을 주석으로 구분해야하는가?
    - 준비 및 검증 구절에 빈줄을 추가해서 구분해야하는 경우가 아니라면 준비, 실행, 검증 구절을 구분하기 위한 주석은 제거한다.
    - 그 외에는 주석을 사용한다.

## [xUnit](https://en.wikipedia.org/wiki/XUnit)
### xUnit 이란?
- xUnit은 특정 형싱을 따르는 유닛테스트의 집합이다.
- 다양하게 언어별로 xUnit의 형식을 따르는 프레임워크가 존재한다.
    - JUnit (Java, Kotlin), CppUnit (C++), GoogleTest (C++), XCTest(ObjC, Swfit)

### 테스트 픽스쳐 재사용
- 테스트 픽스처는 테스트 실행환경을 고정된 상태로 실행하기 위한 객체를 일컷는다. (SUT에 전달되는 인수, 데이터베이스 데이터, 하드디스크 파일 등이 될 수 있다.)
    - 테스트 픽스처가 이러한 고정된 상태를 만드는것에대한 책임을 지면 된다.

- 가능한 테스트에서 준비구절이 생략되지 않도록 테스트 픽스처를 구성하자.
    - 준비구절을 테스트 픽스처의 생성자로 넣거나, SetUp등의 공통된 곳에서 일반화되지 않은 방식으로 작성할 경우 테스트간의 결합도가 높아질 수 있다.
    - 또한 준비구절이 생략되므로 테스트의 가독성이 떨어지게된다. (테스트 구문만 읽고도 테스트 파악이 가능하도록 작성해야함.)
- 테스트 픽스처의 공통 구절은 좀더 일반화 된 방식으로 작성하여 테스트간의 결합도를 낮출 수 있도록 해야한다.

## 단위테스트 명명법
- [테스트 대상 메서드]_[시나리오]_[예상결과] 방법
    - 방식 설명
        - 관습적으로 사용되는 명명법에는 [테스트 대상 메서드]_[시나리오]_[예상결과]의 형태로 작성하는 방법이 있다.
            - 테스트 대상 메서드 : 테서트 중인 메서드의 이름
            - 시나리오 : 메서드를 테스트하는 조건
            - 예상 결과 : 현재 시나리오에서 테스트 대상 메서드에 기대하는것
        - 예시 > 두수의 합을 구하는 테스트 함수는 다음과 같이 작성할 수 있음.
                void Sum_TwoNumbers_ReturnsSum()
    - 단점
        - 테스트의 동작보다 세부사항에 집중하게 만듬.
        - 염격한 명명방식때문에 표현의 자유가 줄어들어 전달하고자 하는 내용이 충분히 전달되지 않을 수 있음.

- 단위테스트 명명 지침
    - 염격한 명명지침은 존재하지 않는다. 내용을 충분히 표현가능하도록 한다.
    - 비즈니스 비전문가도 무엇을 테스트하는지 알아볼수있는 이름이 좋다.
    - 테스트는 스네이크케이스로 작성
        - 가독성이 향상된다
    - 테스트 클래스의 이름으로 [테스트 하고자 하는 클래스명]Tests의 패턴으로 작성되고는 하는데
        테스트는 동작의 단위로 테스트 하는것이기 때문에 꼭 해당 테스트를 테스트 하지 않아도 된다.
        단순히 진입점으로 생각하자.
    - 명명은 간단명료하며 동작의 원자적인 사실을 설명 가능하도록 지어야한다.
        - 영문법도 지켜야함.. (한글로 유닛테스트를 작성하는것도 고려해볼만할듯.)

## 매개변수화된 테스트 리팩터링
- 테스트를 좀더 일반적으로 만들어 메개변수를 넘겨 테스트를 할 수 있음.
- 단 부정값을 테스트하는것과 긍적값을 테스트 하는경우 하나의 테스트로 묶지 않도록 한다. 
    - 내부에서 성공 실패를 구분해야하기때문에 어찌보면 if문 없애기 원칙과도 상동.

- 아래와 같은 3가지 테스트가 있을때
    Delivery_for_today_is_invalid()
    Delivery_for_tomorrow_is_invalid()
    The_soonest_delivery_date_is_t씨o_days_from_now()
    각 테스트는 
    Detects_an_invalid_delivery_date(int daysFromNow)
    The_soonest_delivery_date_is_two_days_from_now()

    의 두가지 형태로 분리 할 수 있음
    Delivery_for_today_is_invalid() -> Detects_an_invalid_delivery_date(0)
    Delivery_for_tomorrow_is_invalid() -> Detects_an_invalid_delivery_date(1)

    The_soonest_delivery_date_is_t씨o_days_from_now() -> The_soonest_delivery_date_is_two_days_from_now()

    - 두개의 테스트로 분리된 이유는 테스트의 긍정값과 부정값에 대한 테스트로 나눠야한다는 지침때문임.
- 메게변수화된 테스트는 조금이라도 테스트 동작이 복잡해질경우 사용하면 안됨.
    
## 개인적인 정리
- 결과적으로 테스트는 조금더 많은 코드를 작성하더라도 명료하게 읽을 수 있도록 해야한다는 것이 핵심인것같다.
    - AAA기법, 리팩토링, 매개변수화된 테스트 리팩터링이 모두 해당 주제로 말하고있음.
- 또한 유닛테스트는 동작을 테스트하는것이라는 부분을 명심하며 테스트를 작성하는것이 중요하다.
- 한국인만 일하는 회사라면 단위테스트는 한글로 테스트명을 작성해도 괜찮을것같다는 생각이 들었다. (어차피 주석도 다들 한글로 다니까..)
    - Delivery_With_a_past_date_is_invalid() -> 과거일자로_배송을_지정하는것은_유효하지않음()
    - 다만 이 부분은 도메인용어 또한 한국어와 영문버전이 필요하게 됨.. 
    - Delivery_과거일자로_지정하는것은_유효하지않음()