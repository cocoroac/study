# 목과 테스트 취약성
## 목과 스텁
- 테스트 대역의 유형
  - 목(Mock)
    - 목은 외부로 나가는 상호작용을 모방한다.
    - 목은 SUT가 상태를 변경하기 위한 의존성 호출이다.
    - 종류는 목과 스파이가 있다.
  - 스텁(Stub)
    - 스텁은 내부로 들어오는 상호작용을 모방한다.
    - 스텁은 SUT가 데이터를 얻기 위한 의존성 호출이다.
    - 종류는 스텁, 더미, 페이크가 있다.
  - 테스트 대역은 사소한 구현의 차이만 있을뿐이다.
  - 도구로서의 목과 테스트 대역으로서의 목을 혼동하면 안된다.
    - 도구로서의 목은 테스트 대역을 만드는 도구 자체를 말하는 것임.
  
## 스텁으로 상효작용을 검증하면 안됨.
- 스텁은 SUT의 세부 구현 사항의 테스트 대역이기 때문에 스텁으로 상호작용을 검증한다면 테스트의 세부사항과 결합하게된다.
- SUT가 어떤 데이터를 가져가 결과를 만들어내는지는 중요하지 않다.
- 최종결과가 아닌 사항을 검증하는 관행을 과잉명세라고 한다.

## 목과 스텁, 명령과 조회
- CQS라는 원칙에 따라 모든 메서드는 명령이거나 조회여야 한다.
- 명령은 사이드 이팩트를 일으키며(무언가의 상태를 변화), 조회는 사이드 이팩트가 없다.
- 가능하면 CQS를 따르도록 해야한다.
- 이러한 원칙에서 볼때 사이드 이팩트가 있다면 목, 사이드 이팩트가 없다면 스텁으로 볼 수 있다.

## 식별할 수 있는 동작과 공개 API
- 식별할 수 있는 동작이 공개 API를 의미하는 것은 아니다. (공개 API는 프로그래밍 언어에서 public 등을 붙여 노출하는 형태의 표현이 존재한다.)
- 식별할 수 있는 동작은 다음중 한가지를 한다.
  - 클라이언트가 목표를 달성하는데 도움이 되는 연산을 노출한다.
  - 클라이언트가 목표를 달성하는데 도움이 되는 상태를 노출한다.
- 클라이언트의 목표가 무엇인지, 클라이언트가 누구인지에따라 식별할 수 있는 동작의 여부는 달라진다.
- 이상적인 시스템의 공개 API는 식별할 수 있는 동작과 일치해야하며 구현 세부사항은 모두 숨겨져야한다.
- 프로그램을 설계하거나 유지보수할 때 구현의 세부사항이 식별할 수 있는 동작의 범위를 넘어 공개 API로 노출되는 일이 생기는 것에 주의해야한다.
- 단일한 목표를 달성하고자 클래스에서 호출해야하는 연산의 수가 1보다 크면 클래스에서 구현 세부사항을 유출할 가능성이 있다.
  - 저자의 경험상 대부분의 비지니스 로직에 해당한다고...

## 캡슐화
- 캡술화는 불변성 위반을 방지하는 조치이다.
- 캡슐화를 통해 불변성 위반으로 구현 세부사항 노출을 막을 수 있다.
- 데이터와 연산을 결합하면 해당 연산이 데이터 불변성 위반을 하지 않도록 할 수 있다.

## 육각형 아키텍처
- 육각형 아키텍처는 도메인 계층과 어플리케이션 계층간의 관심사 분리이다.
  - 도메인계층은 도메인에 대해서만 책임을 져야한다. 또한 도메인 계층은 외부 환경과 완벽하게 격리 되어야한다.
  - 어플리케이션 계층은 도메인 계층을 사용한다. 도메인계층도 어플리케이션 계층의 서비스가 필요할 수 있지만 이러한 것들은 모두 제어역전 등의 방법을 통해 도메인계층의 격리를 이뤄야한다.
  - 어플리케이션 개층은 다른 외부 종속성으로 볼 수 있다. 파일시스템, 데이터베이스, 네티워크 통신 등. 이러한 종속성은 도메인 계층에 강하게 결합되어서는 안된다.
  
## 어플리케이션의 통신
  - 일반적인 어플리케이션 시스템에서 다음과 같은 통신(메세지 교환)이 존재한다.
    - 시스템 내부 통신
      - 육각형 아키텍쳐에서 하나의 모듈안에 있는 객채 간의 통신.
      - 시스템 내부 통신은 클라이언트의 목표와는 직접적인 관계가 없다.
      - 내부 통신에 테스트가 결합하면 리팩토링 내성이 없어진다.
    - 시스템 간 통신
      - 육각형 아키텐쳐에서 여러모듈(서드파티 모듈)에 걸쳐 공개된 인터페이스를 통해 수행되는 통신.
      - 클라이언트의 목표와 직접적인 관계가 있다.
      - 식별할 수 있는 동작으로 인식된다.

## 어떤 의존성을 목으로 대체하는가?
- 어플리케이션 내부에서만 접근하고 통신이 되는 외부 의존성은 구현 세부사항이 될 수 있다.
  - 이러한 동작은 목으로 대체하지 않는다.. (어떻게 해야하는지는 6장과 7장에서 알려준다고함.)
- 어플리케이션과 외부 시스템 간의 통신 패턴을 항상 지켜야하는 요구사항은 하위호환성을 지켜야한다는 것에서 비롯된다.
  - 예시 > 서버 클라이언트 구조에서 서버.. (하위 호환성을 지켜야하며 배포주기가 다르며 제어권한이 없음.)

## 개인적인 정리
- 결국은 캡슐화를 잘하자
- 목을 어디에 써야하는지 배운것같다.
- 육각형 아키텍쳐에 대해서 잘 정리한 책으로 Clean Architecture를 추천한다.
  - 책으로 얻을 수 있는 교훈은 결국 이번장에서 말하고자 하는 교훈과 같다.
    - 유즈케이스를 작성하고, 유즈케이스를 기반으로 도메인과 모델을 나눠라.
    - 다른 계층의 세부 사항이 다른 계층으로 침범하지 않도록 주의해라
      - 결과적으로 모듈을 잘 나눠서 감추라는 의미.
    - 세부 사항은 감춰라. (인터페이스 등으로)
- CQS
  - CQS를 따르면 목과 스텁을 나눠서 구현하는것에 도움을 줄 수 있다는 취지로 넣은것같다.
