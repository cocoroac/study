# 기술 실천 방법

## TDD
### TDD의 세가지 규칙
책에는 다음과 같이 설명했다.

    * 해당 코드가 없어서 실패하는 테스트 코드를 쓰기 전에 제품 코드를 먼 저 쓰면 안 된다.
    * 테스트 코드를 쓸 때는 실패하도록 만들기 위해 필요한 것보다 더 많이 쓰면 안 된다. 컴파일 실패도 실패로 간주한다.
    * 실패하는 테스트를 통과시키기 위해 필요한 코드보다 더 많은 제품 코드 를 쓰면 안 된다.

세가지 규칙이라고 했는데 조금 복잡한것같다
TDD를 예시와 함께 설명하자면 다음과 같다.

요구사항으로 정수 리스트의 평균을 반환하는 함수를 작성해야 한다고하자.
먼저 리스트의 평균을 반환하는 함수라면 다음과 같은 인터페이스를 가질것이다.
```
double average_of_vector(const std::vector<int>& numbers);
```
먼저 첫번째 규칙으로 인해 제품코드를 작성하기 전에 테스트 코드를 작성해야한다.
```
TEST(Test, test_average_of_vector_1) {
    std::vector<int> numbers = {1, 2, 3, 4};
    assert(average_of_vector(numbers) == 2.5);
}
```
먼저 실패하는 테스트 코드를 작성했다. 제품코드를 쓰지 않은상태로 당연히 컴파일 되지 않는다.
이제 테스트 코드를 작성했으니 제품코드를 작성하자 제품코드는 테스트를 통과할 정도로 간단하게 적는다.
```
double average_of_vector(const std::vector<int>& numbers) {
    return 2.5;  // 임시 코드
}
```
테스트를 돌리면 통과한다.
하지만 코드가 완성된 것이 아니므로 다시 테스트 코드를 작성하자
```
TEST(Test, test_average_of_vector_2) {
    std::vector<int> numbers = {2, 4, 6, 8};
    assert(average_of_vector(numbers) == 5.0);
}
```
다시 test_average_of_vector_2로 인해 테스트가 실패하게된다
다시 테스트를 성공 상태로 만들기 위해서 제품코드를 작성한다.
```
double average_of_vector(const std::vector<int>& numbers) {
    double total = 0.0;
    for (int num : numbers) {
        total += num;
    }
    return total / numbers.size();
} 
```
제품코드가 완성되었다. 두개의 테스트가 통과하였다.
여기서 더 나아 제품에 요구되는 제한사항 등을 테스트 케이스에 추가할 수 있을 것이다.
여기서 추가로 제품 코드를 좀더 효율적이고 간결하게 만들기위헤 리펙토링을 수행할 수 있다.
```
double average_of_vector(const std::vector<int>& numbers) {
    double total = std::accumulate(numbers.begin(), numbers.end(), 0.0);
    return total / numbers.size();
}
```

이것이 기본적인 TDD로 제품코드를 작성하는 과정이며, Red-Green-Refactor 주기 라고 부른다.

### TDD의 장점.
* 문서화
    * TDD를 실천하면 동작하는 예제코드가 항상 테스트로 작성되기 때문에 자동으로 문서화가 된다고한다.
    * TDD과정 자체가 재미있다고 ㅡㅡ;;
* 완벽함
    * TDD를 통해 무결한 코드를 만들수 있다고 한다.
    * 왜냐하면 나중에 테스트가 작성된 코드보다 처음부터 테스트를 작성하며 높은 테스트 커버리지를 달성한 코드의 테스트가 더 신뢰 가능하기 때문이라고.
* 설계
    * 처음부터 테스트 가능하도록 제품코드가 작성되었기 때문에 설계 부분에서 좋은 설계가 될 확율이 높다.
    * 이 부분은 공감이 된다. 대부분 테스트하기 쉬운코드가 설계가 좋을 확율이 높다.
* 리펙터링에 대한 용기
    * 테스트 코드가 존재하므로 리펙터링을 시도할때 안전망의 역할을 충실하게 수행해준다.
    * 다만 TDD로 인해 리펙터링시 상단한 피로가 생길수도 있다는 생각이든다. 제품코드를 건드리는 순간 수많은 테스트 코드가 실패하게 될것이므로..
    * 다만 리팩터링 또한 크게 하지말고 작은부분부터 조금씩 고쳐나가라는것이 이 책의 조언이다.

## 리팩터링
당연하지만 리팩터링은 TDD와 밀접한 관련이 있다.
여기서는 TDD과정에서 설명했던 Red-Green-Refactor에 대해서 설명한다.
즉, TDD의 주기는 다음곽 같다.

* Red : 실패하는 테스트 작성하기 (대부분 시스템에서 실패는 빨간색으로 표시된다.)
* Green : 실패하는 테스트를 성공으로 만들기 위해서 제품코드를 작성한다.
* Refactor : Red-Green으로 어느정도 코드가 작성되면 더 효율적으고 좋은 디자인을 찾아서 제품코드를 수정하고 테스트를 통과시킨다.
* 다시 Red 단계로 돌아간다.

즉 TDD는 연속된 리팩터링의 과정이라고 볼 수 있다.

## 단순한 설계
켄트백이 주장한 단순한 설계의 규칙은 다음과 같다
* 모든테스트를통과할것 
* 의도를드러낼것
* 중복을없앨것
* 구성요소를줄일것

## 짝 프로그래밍
### 짝 프로그래밍 진행방법
* 짝프로그래밍은 두명의 프로그래머가 하나의 코드를 보고 같이 업무를 수행하는 것이다.
* 주된 목적은 지식의 공유이며 부가 효과로 에러를 줄이고 더 나은 설계를 할 수 있도록 하는것이다.
* 주로 한사람은 드라이버, 다른 한사람은 네비게이터로 역할을 나누고 업무를 수행한다.
* 드라이버는 코드를 작성하는 사람이다.
* 네비게이터는 코드를 살피고 여러가지 돌파구를 제시하는 사람이다.
* 하지만 꼭 그래야하는 것은 아니고 두사람이 같은 코드를 보고 의견을 나누며 코드를 작성한다는 것이 핵심인것같다.
* 코드를 작성하는과 동시에 코드리뷰가 가능하며 두사람이 같은 업무를 수행하기 때문에 코드에 대한 지식이 두사람에게 동시에 쌓이게되어 지식이 퍼져나가게된다.
* 짝 프로그래밍은 길게 해야하는것은 아니고 그냥 필요할때마다 수시로 하라고한다.
* 여러사람이 회의실에 모여서 진행하는 몹프로그램이라는 형태도 존재한다.
* 고급프로그래머-고급프로그래머 페어보다는 고급프로그래머-초급프로그레머 페어가 좋다.

## 개인적인 정리
* TDD를 꼭 해야하는것은 아닌것같다. 다만 테스트 문화의 확산은 필요하며 중요한 코드에는 꼭 테스트를 작성하자.
* 짝 프로그래밍은 좋은 문화인것같다.
* 단순한 설계의 경우도 초급프로그래머의 경우 쉽지 않을 수 있는데 짝프로그래밍을 통해 어느정도 보안이 가능하며 TDD 실천으로 단순한 설계또한 이뤄낼수 있다고 책에서는 주장하는것으로 생각된다.